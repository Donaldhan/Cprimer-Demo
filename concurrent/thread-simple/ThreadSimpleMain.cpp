
/*
 * @ClassName: ThreadMain
 * @Description:
 * 创建线程时的传参问题分析
 *
 * 如“std::thread th1(proc1)”,创建线程时需要传递函数名作为参数，提供的函数对象会复制到新的线程的内存空间中执行与调用。
 * 如果用于创建线程的函数为含参函数，那么在创建线程时，要一并将函数的参数传入。
 * 常见的，传入的参数的形式有基本数据类型(int，char,string等)、引用、指针、对象这些，
 * 下面总结了传递不同形式的参数时std::thread类的处理机制，以及编写程序时候的注意事项。
 * 本章节只给出了部分示例代码，没有必要为了证明处理机制而举例大量简单代码而使得文章冗长，但是推荐新手自行编写程序研究。
 * 总体来说，std::thread的构造函数会拷贝传入的参数:
 * 1. 当传入参数为基本数据类型(int，char,string等)时，会拷贝一份给创建的线程；
 * 2. 当传入参数为指针时，会浅拷贝一份给创建的线程，也就是说，只会拷贝对象的指针，不会拷贝指针指向的对象本身。
 * 3. 当传入的参数为引用时，实参必须用ref()函数处理后传递给形参，否则编译不通过，
 * 此时不存在“拷贝”行为。引用只是变量的别名，在线程中传递对象的引用，那么该对象始终只有一份，
 * 只是存在多个别名罢了（注意把引用与指针区别开：指针是一块内存指向另一块内存，指针侧重“指向”二字；
 * 引用是只有一块内存，存在多个别名。理解引用时不要想着别名“指向”内存，这是错误的理解，
 * 这样的理解会导致分不清指针和引用，别名与其本体侧重于“一体”二字，引用就是本体，本体就是引用，根本没有“指向”关系。）；
 *
 * 4. 当传入的参数为类对象时，会拷贝一份给创建的线程。此时会调用类对象的拷贝构造函数。
 *
 * @Author:  Ravitn
 * @Date: 2021-03-05 10:26
*/
#include<iostream>
#include<thread>
using namespace std;
void proc(int &a)
{
    cout << "我是子线程,传入参数为" << a << endl;
    cout << "子线程中显示子线程id为" << this_thread::get_id()<< endl;
}
int main()
{
    cout << "我是主线程" << endl;
    int a = 9;
    //第一个参数为函数名，第二个参数为该函数的第一个参数，如果该函数接收多个参数就依次写在后面。此时线程开始执行。
//    thread-simple th2(proc,a);
    thread th2(proc,std::ref(a));
    cout << "主线程中显示子线程id为" << th2.get_id() << endl;
    //此时主线程被阻塞直至子线程执行结束。
    th2.join();
    cout << "done" << endl;
    /*
     * 使用detach()时，可能存在主线程比子线程先结束的情况，
     * 主线程结束后会释放掉自身的内存空间；在创建线程时，如果std::thread类传入的参数含有引用或指针，
     * 则子线程中的数据依赖于主线程中的内存，主线程结束后会释放掉自身的内存空间，则子线程会出现错误。
     */
//    th2.detach();
}

